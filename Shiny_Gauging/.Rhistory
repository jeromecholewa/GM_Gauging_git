res
sentence1 <- "This is a short sentence consisting of some words which can be over"
sentence2 <- "This is a short sentence consisting of some words which are over"
p1 = tagPOS(sentence1, language = "en")
p2 = tagPOS(sentence2, language = "en")
#p
#p[[1]]
x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB.?")
x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB.?")
#x[[1]]
sapply(strsplit(p1[[1]], "[[:punct:]]*/VB.?"), splitter)
sapply(strsplit(p2[[1]], "[[:punct:]]*/VB.?"), splitter)
res1 = sub("(^.*\\s)(\\w+$)", "\\2", x1[[1]])
res2 = sub("(^.*\\s)(\\w+$)", "\\2", x2[[1]])
grepl("\\s", res1)
grepl("\\s", res2)
res1
res2
p1
p2
sentence1 <- "This is a short sentence consisting of some words which can be over"
sentence2 <- "This is a short sentence consisting of some words which are over"
p1 = tagPOS(sentence1, language = "en")
p2 = tagPOS(sentence2, language = "en")
#p
#p[[1]]
#x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB.?")
#x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB.?")
x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
#x[[1]]
sapply(strsplit(p1[[1]], "[[:punct:]]*/VB.?"), splitter)
sapply(strsplit(p2[[1]], "[[:punct:]]*/VB.?"), splitter)
res1 = sub("(^.*\\s)(\\w+$)", "\\2", x1[[1]])
res2 = sub("(^.*\\s)(\\w+$)", "\\2", x2[[1]])
grepl("\\s", res1)
grepl("\\s", res2)
res1
res2
sapply(strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
sapply(strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
res1 = sub("(^.*\\s)(\\w+$)", "\\2", x1[[1]])
res2 = sub("(^.*\\s)(\\w+$)", "\\2", x2[[1]])
grepl("\\s", res1)
grepl("\\s", res2)
res1
res2
sentence1 <- "This is a short  sentence that be thing consisting of some words which can be over"
sentence2 <- "This is a short sentence that is thing consisting of some words which are over"
p1 = tagPOS(sentence1, language = "en")
p2 = tagPOS(sentence2, language = "en")
#p
#p[[1]]
#x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB.?")
#x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB.?")
x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
#x[[1]]
sapply(strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
sapply(strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
res1 = sub("(^.*\\s)(\\w+$)", "\\2", x1[[1]])
res2 = sub("(^.*\\s)(\\w+$)", "\\2", x2[[1]])
grepl("\\s", res1)
grepl("\\s", res2)
res1
res2
x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB.?")
x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB.?")
#x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
#x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
#x[[1]]
#sapply(strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
#sapply(strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
sapply(strsplit(p1[[1]], "[[:punct:]]*/VB.?"), splitter)
sapply(strsplit(p2[[1]], "[[:punct:]]*/VB.?"), splitter)
res1 = sub("(^.*\\s)(\\w+$)", "\\2", x1[[1]])
res2 = sub("(^.*\\s)(\\w+$)", "\\2", x2[[1]])
grepl("\\s", res1)
grepl("\\s", res2)
res1
res2
sentence1 <- "This is a short  sentence that be thing consisting of some words which can be over come then"
sentence2 <- "This is a short sentence that is thing consisting of some words which are over come then"
p1 = tagPOS(sentence1, language = "en")
p2 = tagPOS(sentence2, language = "en")
#p
#p[[1]]
x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB.?")
x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB.?")
#x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
#x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?")
#x[[1]]
#sapply(strsplit(p1[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
#sapply(strsplit(p2[[1]], "[[:punct:]]*/VB[[:alpha:]]?"), splitter)
sapply(strsplit(p1[[1]], "[[:punct:]]*/VB.?"), splitter)
sapply(strsplit(p2[[1]], "[[:punct:]]*/VB.?"), splitter)
res1 = sub("(^.*\\s)(\\w+$)", "\\2", x1[[1]])
res2 = sub("(^.*\\s)(\\w+$)", "\\2", x2[[1]])
grepl("\\s", res1)
grepl("\\s", res2)
res1
res2
x1
p1[[1]]
2[[1]]
p2[[1]]
rm(tagPOS)
library("openNLPdata", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
gsub("([ab])", "\\1_\\1_", "abc and ABC")
txt <- "a test of capitalizing"
gsub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)
sub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)
gsub("(\\w)(\\w*)", "\\U\\1", txt, perl=TRUE)
txt <- "test of capitalizing"
gsub("(\\w)(\\w*)", "\\U\\1\\L\\2", txt, perl=TRUE)
gsub("(\\w)(\\w*)", "\\U\\1", txt, perl=TRUE)
gsub("(\\w)", "\\U\\1", txt, perl=TRUE)
sub("(\\w)", "\\U\\1", txt, perl=TRUE)
sub("(\\w)", "\\U\\2", txt, perl=TRUE)
sub("(\\w)", "\\U\\3", txt, perl=TRUE)
sub("(\\w)", "\\U\\1", txt, perl=TRUE)
sub("\\w", "\\U\\1", txt, perl=TRUE)
sub("\\w", "\\U", txt, perl=TRUE)
sub("\\w", "\\U\\1", txt, perl=TRUE)
sub("\\w", "\\U", txt, perl=TRUE)
sub("\\w", "", txt, perl=TRUE)
sub("\\w", "\\E\\1", txt, perl=TRUE)
sub("(\\w)", "\\E\\1", txt, perl=TRUE)
sub("(\\w)", "\\1", txt, perl=TRUE)
sub("(\\w)", "\\1", txt, perl=TRUE)
txt <- "test of Capitalizing"
sub("(\\w)", "\\1", txt, perl=TRUE)
sub("\\w", "\\U", txt, perl=TRUE)
sub("\\w", "\\U\\1", txt, perl=TRUE)
gsub("\\w", "\\U\\1", txt, perl=TRUE)
sub("\\w", "\\U\\1", txt, perl=TRUE)
gsub("\\w", "\\U\\1", txt, perl=TRUE)
txt
sub("(\\w)", "\\U\\1", txt, perl=TRUE)
sub("\\w", "\\U\\1", txt, perl=TRUE)
sub("\\w", "\\U", txt, perl=TRUE)
gsub("(\\w)", "\\U\\1", txt, perl=TRUE)
gsub("\\w", "\\U\\1", txt, perl=TRUE)
sub("\\w", "\\U", txt, perl=TRUE)
gsub("\\w", "\\U", txt, perl=TRUE)
gsub("(\\w)", "\\U", txt, perl=TRUE)
gsub("(\\w)", "\\U\1", txt, perl=TRUE)
gsub("(\\w)", "\\U\\1", txt, perl=TRUE)
gsub("(\\w)", "\\U\\2", txt, perl=TRUE)
gregexpr("(\\w)(\\w*)", txt)
gregexpr("(\\w)", txt)
txt <- "test ,of .Capitalizing"
gregexpr("(\\w)(\\w*)", txt)
gregexpr("(\\w)", txt)
gregexpr("\\w", txt)
grep("\\w", txt, value = TRUE)
grep("(\\w)", txt, value = TRUE)
gregexpr("\\w", txt)[[1]]
gregexpr("\\w", txt)[[1]][1]
gregexpr("\\w", txt)[[1]][[1]]
gregexpr("\\w", txt)[[1]]
str(gregexpr("\\w", txt)[[1]])
gregexpr("\\w", txt)[[1]]$1
gregexpr("\\w", txt)[[1]]
try <- "rtgrg .;"
splitter(try)
try <- "rtgrg .;k"
splitter(try)
try <- "rtgrg k.;"
splitter(try)
res = sub("(^.*\\s)(\\w+$)", "\\2", try)
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- "rtgrg k.;"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " rtgrg k.;"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " rt.grg k.;"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " rt.grg k"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " rt.grg k."
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- "asdasd.kqqw"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- "asd asd.kqqw"
try <- "asd asd.kqqw"
sub("(^.*\\s)(\\w+$)", "\\2", try)
sentence1 <- "This is a short  sentence that be thing consisting of some words which can be over"
sentence2 <- "This is a short sentence that is thing consisting of some words which are over"
p1 = tagPOS(sentence1, language = "en")
p2 = tagPOS(sentence2, language = "en")
tagPOS <-  function(x, ...) {
s <- as.String(x)
word_token_annotator <- Maxent_Word_Token_Annotator()
a2 <- Annotation(1L, "sentence", 1L, nchar(s))
a2 <- annotate(s, word_token_annotator, a2)
a3 <- annotate(s, Maxent_POS_Tag_Annotator(), a2)
a3w <- a3[a3$type == "word"]
POStags <- unlist(lapply(a3w$features, `[[`, "POS"))
POStagged <- paste(sprintf("%s/%s", s[a3w], POStags), collapse = " ")
list(POStagged = POStagged, POStags = POStags)
}
sentence1 <- "This is a short  sentence that be thing consisting of some words which can be over"
sentence2 <- "This is a short sentence that is thing consisting of some words which are over"
p1 = tagPOS(sentence1, language = "en")
p2 = tagPOS(sentence2, language = "en")
x1 <- strsplit(p1[[1]], "[[:punct:]]*/VB.?")
x2 <- strsplit(p2[[1]], "[[:punct:]]*/VB.?")
x1
x2
try <- "asd asd.kqqw"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- "asd asdkqqw"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " asd asdkqqw"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " asd as.dkqqw"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " asd .asdkqqw"
sub("(^.*\\s)(\\w+$)", "\\2", try)
sapply(strsplit(p1[[1]], "[[:punct:]]*/VB.?"), splitter)
sapply(strsplit(p2[[1]], "[[:punct:]]*/VB.?"), splitter)
try <- " over/IN"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " over"
sub("(^.*\\s)(\\w+$)", "\\2", try)
try <- " over/IN"
sub("(^.*\\s)(\\w+$)", "\\2", try)
install.packages(c("assertthat", "curl", "RcppArmadillo", "zoo"))
library("tm", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
xa <- seq(-4,4,.1)
rm(list = ls())
xa <- seq(-4,4,.1)
nanorm <- dnorm(xa)
lines(xa, nanorm)
lines(stats::lowess(cars))
plot(xa, nanorm)
plot(xa, nanorm, type = "l", col = "red", lwd = 2)
n <- 1000
gaussian_rv <- rnorm(n)
qqnorm(gaussian_rv)
qqline(gaussian_rv, col = "blue", lwd = 2)
qnorm(0)
qnorm(.5)
install.packages(c("backports", "car", "caret", "chron", "CORElearn", "curl", "digest", "doMC", "DRR", "foreach", "git2r", "Hmisc", "hms", "htmlTable", "iterators", "knitr", "lme4", "MASS", "quantmod", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "recipes", "reshape2", "rgdal", "rlang", "rprojroot", "RWeka", "RWekajars", "sf", "sp", "spdep", "testthat", "tibble", "tm", "tmap", "tmaptools", "units", "viridis", "webshot", "withr", "xts", "yaml", "zoo"))
install.packages(c("Hmisc", "RWeka", "RWekajars", "sf"))
install.packages("sf")
install.packages(c("Hmisc", "RWeka", "RWekajars", "sf"))
install.packages(c("digest", "haven", "hexbin", "Hmisc", "lava", "mgcv", "pillar", "recipes", "rpart", "RWeka", "RWekajars", "sf", "sp"))
install.packages(c("BH", "ddalpha", "digest", "hexbin", "hms", "htmlTable", "htmlwidgets", "knitr", "lubridate", "mapview", "mgcv", "openssl", "quantreg", "Rcpp", "RcppEigen", "RcppParallel", "rio", "RWeka", "RWekajars", "sf", "spData", "swirlify", "tibble", "tidyr", "tmap", "tmaptools", "tseries", "TTR", "viridis", "viridisLite", "xml2"))
install.packages(c("MASS", "mgcv", "rpart"))
install.packages("knitr")
install.packages(c("knitr", "MASS", "nlme", "rpart", "stringr", "yaml"))
rm(list = ls())
sport <- c("Hockey", "Baseball", "Football")
league <- c("NHL", "MLB", "NFL")
trophy <- c("Stanley Cup", "Commissioner's Trophy",
"Vince Lombardi Trophy")
trophies1 <- cbind(sport, league, trophy)
trophies1
str(trophies1)
trophies2 <- data.frame(sport=c("Basketball", "Golf"),
league=c("NBA", "PGA"),
trophy=c("Larry O'Brien Championship Trophy",
"Wanamaker Trophy"),
stringsAsFactors=FALSE)
trophies2
trophies <- rbind(trophies1, trophies2)
trophies
install.packages(c("stringi", "yaml"))
install.packages(c("cluster", "Matrix"))
install.packages("Matrix")
library("dplyr")
library("readxl")
library(xlsx) # for write.xlsx
library(zoo)  # for rollmean (but we can just use zoo::rollmean)
library(plotly)
#library(data.table)
setwd("~/Documents/Education/Coursera/Datascience with R/GM_gauging/9BUX FWD Gauge/")  # enter correct folder for original file   ON MAC
rm(list = ls())
###########
# characteristics of the tank and project
dyn_unuse <- 0  # acc to GMW 14474, must be given by GM
useable_vol <- 50
##########
#pad_gap <- 0.2  # enter the appropriate value = the smallest gap between all the
# resistance values of the resistor card
#pad_gap_roll <- 0.11
#min_values_per_pad <- 6 # how many readings are considered the minimum to
# consider being a "pad"
# That avoids singletons (= measurement "glitches")
#ok_range <- 0.9 # range within which a point belongs to a specific segment
# RESOLUTION <- pad_gap / 2          # within one pad, observations with values outside of this ohm tolerance
# RESOLUTION_roll <- pad_gap_roll / 2   # will be deleted (local outliers)
filename <- "9BUX_FWD_4_TY_4_Drain R1" #  REMOVE the '.xlsx' from original file name
#filename <- "salaires_2011_2013" #  REMOVE the '.xlsx' from original file name
gauging <- read.csv(paste(filename, ".csv", sep = ""),
header = FALSE)
gauging <-  as.data.frame(sapply(gauging[,1:9], as.numeric))
#gauging_x <- data.frame(read_excel(paste(filename, ".xlsx", sep = ""), sheet = 1,
#                       #skip = 1,
#                       na = "", col_names = FALSE))
# head(gauging,25)
# dim(gauging)
# str(gauging)
# str(gauging_x)
# head(gauging, 5)
# head(gauging_x, 5)
if (dim(gauging)[2] != 9 || dim(gauging)[1] <1000 || gauging[1,1] != 0.1) {
print("Wrong")
}
colnames(gauging) <- c( "Time_s", "Liters", "mm", "H2", "Ohms",
"Ohms2" , "G", "H", "I" )
# colnames(gauging_x) <- c( "Time_s", "Liters", "mm", "H2", "Ohms",
#                         "Ohms2" , "G", "H", "I" )
#identical(gauging, gauging_x)
auxiliary <- TRUE
if (mean(gauging$H2) < 3) {
#remove the "H2" and F, G H I columns (c(4,6,7,8,9)) by keeping th rest
gauging <- gauging[,c("Time_s", "Liters", "mm", "Ohms")]
auxiliary <- FALSE
}
gauging <- gauging[!(is.na(gauging$Liters)),]
#tail(gauging,10)
# replace the first NA of the "mm" column by 0
gauging[is.na(gauging$mm),2] <-  0
#head(gauging,6)
# replace the first NA of the "Ohms" column with the first actual measured value
gauging[is.na(gauging$Ohms),3] <-  gauging[!is.na(gauging$Ohms),3][1]
#head(gauging,10)
# reverses the order of the dataframe to have descending liters
# no matter whether the test was draining or filling
gauging <- gauging[with(gauging, order(-Liters)), ]
rownames(gauging) <- NULL   # resets the row names from 1 without "holes"
#gauging <- arrange(gauging, -row_number()) # not accurate since we do not control
#  by which column we sort
gauging$Liters <- gauging$Liters - dyn_unuse
length_g <- length(gauging$Ohms)
gauging$row <- 1:length_g
rolling_k <- 40  # sample size to calculate rolling mean
gauging$rollMean <- rollmean(gauging$Ohms, rolling_k, fill = 0)
gauging$rollMean[1:(round(rolling_k/2)+2)] <- gauging$rollMean[round(rolling_k/2)+3]
gauging$rollMean[(length_g-(round(rolling_k/2)+2)):length_g] <- gauging$rollMean[length_g-(round(rolling_k/2)+3)]
head(gauging,10)
tail(gauging)
gauging$rollStd <- sqrt((rolling_k/(rolling_k-1)) *
(rollmean((gauging$rollMean)^2,
rolling_k, fill = 0) -
rollmean(gauging$rollMean,
rolling_k, fill = 0)^2))
gauging$rollStd[1:(round(rolling_k/2)+2)] <- gauging$rollStd[round(rolling_k/2)+3]
gauging$rollStd[(length_g-(round(rolling_k/2)+2)):length_g] <- gauging$rollStd[length_g-(round(rolling_k/2)+3)]
tail(gauging)
head(gauging,10)
str(gauging$rollStd)
mean(gauging$rollStd)
max(gauging$rollStd)
min(gauging$rollStd)
sum(is.nan(gauging$rollStd))
library(pracma)
rolling_k2 <- 6 # to smoothen the rolling std Dev
gauging$rollMeanOfStdev <- rollmean(gauging$rollStd, rolling_k2, fill = 0)
gauging$rollMeanOfStdev[1:(round(rolling_k2/2)+2)] <- gauging$rollMeanOfStdev[round(rolling_k2/2)+3]
gauging$rollMeanOfStdev[(length_g-(round(rolling_k2/2)+2)):length_g] <- gauging$rollMeanOfStdev[length_g-(round(rolling_k2/2)+3)]
min_peak <- 0.35
peaksTable <- findpeaks(gauging$rollStd, nups = 5, zero = "0", peakpat = NULL, minpeakheight = min_peak, minpeakdistance = 1, threshold = 0, npeaks = 0, sortstr = FALSE)
peaksIndex <- peaksTable[,2] + 1
warnings()
gauging$padChange <- 0
gauging[peaksIndex, "padChange"] <- 1
# head(gauging[peaksIndex, ])
# tail(gauging[peaksIndex, ])
# create "pad_nb" column by cumulative calculation of pad_change
gauging$pad_nb <- cumsum(gauging$padChange) + 1
# gauging$pad_nb_Display <- gauging$pad_nb * 3
warnings()
padTable <- function(pad_listt) {
length_list <- length(pad_listt)
pad_nb <- 1:length_list
pad_averages <- 1:length_list
pad_stdev <- 1:length_list
pad_length <- 1:length_list
pad_min <- 1:length_list
pad_max <- 1:length_list
#pad_ok_min <- 1:length_list
#pad_ok_max <- 1:length_list
pad_range <- 1:length_list
pad_ohm_gap2next <- 1:length_list
#ok_gap2next <- 1:length_list
#xx <- 1:length_list
pad_list_tablee <- as.data.frame(cbind (pad_nb, pad_averages,
#xx,
pad_min, pad_max, pad_range,
#pad_ok_min, pad_ok_max, ok_gap2next
pad_length, pad_stdev, pad_ohm_gap2next
))
# calculate ohm average, std dev and length within each pad
for (i in 1:length_list) {
#pad_list_tablee$xx[i] <- "x"
pad_list_tablee$pad_averages[i] <-mean(pad_listt[[i]])
pad_list_tablee$pad_stdev[i] <- sd(pad_listt[[i]])
pad_list_tablee$pad_length[i] <- length(pad_listt[[i]])
pad_list_tablee$pad_min[i] <- min(pad_listt[[i]])
pad_list_tablee$pad_max[i] <- max(pad_listt[[i]])
pad_list_tablee$pad_range[i] <- pad_list_tablee$pad_max[i] - pad_list_tablee$pad_min[i]
}
#### DETERMINE THE gap  (in OHMS) between 2 segments
for (i in 1:(length_list-1)) {
pad_list_tablee$pad_ohm_gap2next[i] <- abs(pad_list_tablee$pad_averages[i+1] -
pad_list_tablee$pad_averages[i])
}
pad_list_tablee$pad_ohm_gap2next[length_list] <- pad_list_tablee$pad_ohm_gap2next[length_list-1]
return(pad_list_tablee)
}
######## AT THIS POINT we will associate each volume point to a pad number
## So we will build the pad list, simply based on the pad number!
## but now we are recording the raw Ohm values, not the rolling mean
lengg <- max(gauging$pad_nb)
pad_list_final <- vector("list", length = lengg) # initialize the list of segments
########
for (i in 1:lengg) {
pad_list_final[[i]] <- gauging[gauging$pad_nb == i, "Ohms"]
}
# pad_list_final
#
warnings()
pad_list_table_final <- padTable(pad_list_final)
# head(pad_list_table_final)
# pad
warnings()
pad_list_table_final$Liter_start <- pad_list_table_final$pad_nb
pad_list_table_final$Liter_end <- pad_list_table_final$pad_nb
for (i in pad_list_table_final$pad_nb) {
pad_list_table_final$Liter_start[i] <- min(gauging[gauging$pad_nb == i , ]$Liters)
pad_list_table_final$Liter_end[i] <- max(gauging[gauging$pad_nb == i , ]$Liters)
}
#### Just for info, we are displaying the gap in liters separating 2 segments
# this is just to check that there are no big gaps between segments
pad_list_table_final$liter_gap <- pad_list_table_final$pad_nb
for (i in 1:length(pad_list_table_final$pad_nb)-1) {
pad_list_table_final$liter_gap[i] <- abs(pad_list_table_final$Liter_end[i+1] - pad_list_table_final$Liter_start[i])
}
warnings()
GM_table <- pad_list_table_final[,c("pad_nb","pad_averages", "Liter_start",
"Liter_end", "liter_gap", "pad_stdev",
"pad_ohm_gap2next")]
GM_table$Liter_start[GM_table$Liter_start <0] <-  0
GM_table$Liter_end[GM_table$Liter_end <0] <-  0
#head(GM_table)
names(GM_table) <- c("Resistance Change", "Primary Level Sensor Ohms",
"Start Liters UsableFuel InTank",
"End Liters UsableFuel InTank", "Liter gap",
"Segment stddev",
"Segment ohm gap to next")
GM_table$`Secondary Level Sensor Ohms` <- 0
GM_table$`Start Percent UsableFuel InTank` <- 100 * GM_table$`Start Liters UsableFuel InTank` / useable_vol
GM_table$`End Percent UsableFuel InTank` <- 100 * GM_table$`End Liters UsableFuel InTank` / useable_vol
GM_table$`Primary Percent 5V Ref` <- 100 * GM_table$`Primary Level Sensor Ohms` / (243+GM_table$`Primary Level Sensor Ohms`)
GM_table$`Secondary Percent 5V Ref` <- 100 * GM_table$`Secondary Level Sensor Ohms` / (243+GM_table$`Secondary Level Sensor Ohms`)
##### We put all columsn in correct order
GM_table <-GM_table[,c("Resistance Change", "Primary Level Sensor Ohms", "Secondary Level Sensor Ohms",
"Start Percent UsableFuel InTank", "End Percent UsableFuel InTank",
"Start Liters UsableFuel InTank", "End Liters UsableFuel InTank",
"Primary Percent 5V Ref", "Secondary Percent 5V Ref", "Liter gap",
"Segment stddev",
"Segment ohm gap to next")]
#head(GM_tab
warnings()
gauging$couleur <- gauging$pad_nb %% 4
###### rollStDev for display only (x20  for visibility on the graph)
gauging$rollStdDisplay <- 20 * gauging$rollStd
gauging$rollMeanOfStdevDisplay <- 20 * gauging$rollMeanOfStdev
p <- plot_ly(gauging) %>%
# add_trace(x = ~Liters, y = ~rollMean,type = "scatter", mode ="markers",
#       sizes = .1, color = I("green"), name = 'Rolling Mean Resistances\n   = smoothened',
#       hoverinfo = 'text',
#       text = ~paste('Pad_Nb: ', pad_nb,
#                     '</br></br> Volume: ', Liters,
#                     '</br> RollMean: ', rollMean)) %>%
add_trace(x = ~Liters, y = ~Ohms,type = "scatter", mode ="markers",
sizes = .1, color = ~couleur,
name = 'Raw Resistances', hoverinfo = 'text',
text = ~paste('Pad_Nb: ', pad_nb,
'</br></br> Volume: ', Liters,
'</br> Ohms: ', Ohms)) %>%
add_trace(x = ~Liters, y = ~rollStdDisplay, type = "scatter", mode ="markers",
sizes = .1, color = ~couleur, name = 'Rolling StDev (x20)',
hoverinfo = 'text',
text = ~paste('Pad_Nb: ', pad_nb,
'</br> </br> Volume: ', Liters,
'</br> rollStdDisplay: ',
rollStdDisplay)) %>%
# add_trace(x = ~Liters, y = ~rollMeanOfStdevDisplay, type = "scatter", mode ="markers",
#           sizes = .1, color = ~couleur, name = 'Rolling Mean of rolling StDev (x20)',
#           hoverinfo = 'text',
#           text = ~paste('Pad_Nb: ', pad_nb,
#                         '</br> </br> Volume: ', Liters,
#                         '</br> rollMeanOfStdevDisplay: ',
#                         rollMeanOfStdevDisplay)) %>%
# # add_trace(x = ~Liters, y = ~pad_nb_Display,type = "scatter", mode ="markers",
#           sizes = .1, color = I("yellow"), name = 'Pad_number') %>%
# add_trace(x = ~Liters, y = ~pad_nb_up_Display,type = "scatter", mode ="markers",
#           sizes = .1, color = I("pink"), name = 'Pad_number_up') %>%
layout(title = "Raw line and smooth line (rolling averages) &\nrolling StDev (x20 for visibility)",
xaxis = list(title = "Volume (liters)"),
yaxis = list(title = "Resistance (Ohms)"),
legend = list(x = 0.7, y = 0.9)
) %>%
hide_colorbar()
p
install.packages(c("cluster", "Matrix", "nlme"))
shiny::runApp('~/Documents/Education/Coursera/Datascience with R/GM_gauging/Shiny_Gauging')
